var fs = require('fs');
var mysql = require('mysql');
var Hashids = require("hashids"),
		hashids = new Hashids("bbatpyp12345", 4, 'abcdefghijklmnopqrstuvwxyz123456789'); // Salt, min length of hash, alphabet

var gm = require('gm');

// Generate short hash keys from a positive integer so users can key them easily
genKey = function (inInt) {
	return hashids.encrypt(inInt);
};


/*
Handler URL: /ops/file-uploader

Dependancies:
		This connect middleware can only be called after .use(connect.bodyParser())
		Since it depends on the parsing of the form upload data

Input:
		req.files will hold uploaded files from form with enctype="multipart/form-data"
		settings posted via form
				max_files: If more than this value, an error will be returned. Default is 1
				control_rec_id: If provided, insert into DB to represent db record id uploads are related to
				thumbsize: JSON string: {width: xxx, height: yyy} Size of thumbmail to return. Default returns no thumbnail
				title: If provided, any files uploaded will each get this same title
				site_path: Path where uploaded files will be placed - relative to 'public' web root folder

Returns:
	{
		status: 'OK' or 'ERROR',
		status_msg: '' detailed status message,
		uploads: [] array of uploaded files objects which contain
			{
				originalFileName: '' original file name
				newFileName: '' new hashed file name
				uploadedURL: '' full http path to file uploaded
				uploadedImageSize: {width: xxx, height: yyy} FOR IMAGES, Actual image size uploaded
				thumbURL: '' FOR IMAGES, full http path to thumbnail of file uploaded
				thumbSize: {width: xx, height: yyy} FOR IMAGES, thumb size if thumb was requested
			}
	}

*/


uploadFiles = function (env_settings) {

	return function uploadFile(req, res, next) {

		var max_files = req.body.max_files || 1;
		var site_path = req.body.site_path;
		var control_code = req.body.control_code;
		var control_rec_id = req.body.control_rec_id;
		var thumbsizeJSON = req.body.thumbsize;
		var thumbSize;

		var userFiles = [];
		var uploadedFiles = [];

		if ('/ops/file-uploader' == req.url) {

			console.log('Upload started...');

			if (Array.isArray(req.files.userImages)) {
				userFiles = req.files.userImages;
			} else {
				userFiles.push(req.files.userImages);
			}

			// Validate input
			if (userFiles.length > max_files) {
				if (max_files > 1) {
					res.end(JSON.stringify({
						status: 'ERROR',
						status_msg: 'You can only load up to ' + max_files + ' images.'
					}));
					return;
				} else {
					res.end(JSON.stringify({
						status: 'ERROR',
						status_msg: 'You can only load one image at a time.'
					}));
					return;
				}
			}

			if (!site_path) {
				res.end(JSON.stringify({
					status: 'ERROR',
					status_msg: 'site_path not provided.'
				}));
				return;
			}

			if (!control_code) {
				res.end(JSON.stringify({
					status: 'ERROR',
					status_msg: 'control_code not provided.'
				}));
				return;
			}

			if (control_rec_id) {
				if (control_rec_id != parseInt(control_rec_id)) {
					res.end(JSON.stringify({
						status: 'ERROR',
						status_msg: 'control_rec_id invalid.'
					}));
					return;
				}
			}

			if (thumbsizeJSON) {
				try {
					thumbSize = JSON.parse(thumbsizeJSON);
				} catch(err) {
					res.end(JSON.stringify({
						status: 'ERROR',
						status_msg: 'Error parsing JSON thumbsize'
					}));
					return;
				}
			}

			console.log('Starting upload process.');

			// Call recursive function to process all files in array
			processFiles(userFiles, uploadedFiles);

		} else {
			next();
		}


		function processFiles(filesArray, uploadedFilesArray) {

			var thisArray, pathToServer, userFilename, file_ext, sql, hash, dbid;
			var dt = new Date();
			var connectionInfo = env_settings.dbConnSettings;
			var connection;

			if (filesArray.length > 0) {
				thisArray = filesArray.shift();

				userFilename = thisArray.name;

				pathToServer = env_settings.webroot_path;

				file_ext = userFilename.split('.').pop();
				console.log('Processing file ' + userFilename + ' with extension ' + file_ext);

				connection = mysql.createConnection(connectionInfo);

				sql = 'INSERT INTO file_uploads (';
				sql += 'control_code,';

				if (control_rec_id) {
					sql += 'control_rec_id,';
				}

				sql += 'user_filename,';
				sql += 'file_ext,';
				sql += 'upload_date';
				sql += ') values (';
				sql += connection.escape(control_code) + ',';

				if (control_rec_id) {
					sql += connection.escape(+control_rec_id) + ',';
				}

				sql += connection.escape(userFilename) + ',';
				sql += connection.escape(file_ext) + ',';
				sql += connection.escape(dt);
				sql += ')';

				console.log(sql);

				connection.query(sql, function(err, result) {
					if (err) throw err;

					hash = genKey(result.insertId);
					dbid = result.insertId;
					console.log('Insert complete - new id is ' + result.insertId + ' and hash is ' + hash);

					console.log('Rename ' + thisArray.path + ' to ' + pathToServer + site_path + hash + '.' + file_ext);

					fs.rename(
					thisArray.path,
					pathToServer + site_path + hash + '.' + file_ext,
					function(error) {
						if (error) {
							console.log(error);
							res.end(JSON.stringify({status: 'ERROR',
								status_msg: 'File uploaded cancelled, server error: ' + error
							}));
							return;
						}

						// Create Thumbnail
						var largeImageFile = pathToServer + site_path + hash + '.' + file_ext;
						var smallImageFile = pathToServer + site_path + hash + '_thumb.' + file_ext;

						console.log('Thumbsize: ' + JSON.stringify(thumbSize));
						var aspect, resizeHeight, resizeWidth;

						// Get uploaded image size
						gm(largeImageFile)
							.size(function (err, size) {
							if (err) throw err;

							// Resize to keep largest dimmension
							aspect = (size.width > size.height ? 'wider' : 'taller');

							if (aspect == 'wider') {
								resizeHeight = thumbSize.height;
								resizeWidth = Math.round(thumbSize.height * (size.width / size.height));
							} else {
								resizeWidth = thumbSize.width;
								resizeHeight = Math.round(thumbSize.width * (size.height / size.width));
							}

							// Resize image, trim to thumbnail aspect ratio, write to disk
							gm(largeImageFile)
							.resize(resizeWidth, resizeHeight)
							.gravity('Center')
							.extent(thumbSize.width, thumbSize.height)
							.write(smallImageFile, function (error) {
								if (err) throw err;

								sql = "UPDATE file_uploads SET hash = " + connection.escape(hash) + ",";
								sql += "file_url = " + connection.escape(site_path + hash + '.' + file_ext) + ", ";
								sql += 'thumb_url = ' + connection.escape(site_path + hash + '_thumb.' + file_ext) + " ";
								sql += "WHERE id = " + result.insertId;

								console.log(sql);

								connection.query(sql, function(err, result) {
									if (err) throw err;

									uploadedFilesArray.push({
									img_path: site_path + hash + '.' + file_ext,
									img_thumb_path: site_path + hash + '_thumb.' + file_ext,
									id: dbid
									});

									processFiles(filesArray, uploadedFilesArray);

								});

							});

						});

					});

				});


			} else {
				// All files complete
				console.log('Done all files in array');
				console.log(JSON.stringify(uploadedFilesArray));

				res.end(JSON.stringify({
					status: 'OK',
					status_msg: '',
					uploads: uploadedFilesArray
				}));
				return;
			}
				
		}

	};
};


/* Expose public functions ------ */
exports.uploadFiles = uploadFiles;



